{"version":3,"file":"index.js","sources":["../src/helpers/tsReader.ts","../src/helpers/paths.ts","../src/helpers/formatter.ts","../src/helpers/templates.ts","../src/helpers/constants.ts","../src/writer/stringBuilder.ts","../src/parser/utils.ts","../src/parser/schema.ts","../src/helpers/typeSanitization.ts","../src/helpers/generator.ts","../src/helpers/cli.ts","../src/index.ts"],"sourcesContent":["import {\n  Project,\n  Node,\n  SyntaxKind,\n  MethodDeclaration,\n  SourceFile,\n  VariableDeclaration,\n  ExportAssignment,\n  ObjectLiteralExpression\n} from \"ts-morph\";\nimport glob from \"glob\";\nimport path from \"path\";\nimport * as fs from \"fs\";\nimport stripJsonComments from \"strip-json-comments\";\nimport resolve from \"resolve\";\nimport { TsReaderModelTypes } from \"../types\";\n\nfunction getNameAndType(funcDeclaration: MethodDeclaration) {\n  const name = funcDeclaration.getName();\n  const typeNode = funcDeclaration.getType();\n  const type = typeNode.getText(funcDeclaration);\n  return { name, type };\n}\n\nfunction findCommentsInFile(\n  sourceFile: SourceFile,\n  modelTypes: TsReaderModelTypes,\n  maxCommentDepth: number\n) {\n  // TODO: this is reused from findTypesInFile, should abstract out instead\n  const schemaModelMapping: {\n    [schemaVariableName: string]: string;\n  } = {};\n\n  Object.keys(modelTypes).forEach((modelName: string) => {\n    const { schemaVariableName } = modelTypes[modelName];\n    if (schemaVariableName) schemaModelMapping[schemaVariableName] = modelName;\n  });\n\n  for (const statement of sourceFile.getStatements()) {\n    if (!Node.isVariableStatement(statement)) continue;\n    const varDeclarationList = statement.getChildAtIndexIfKind(\n      0,\n      SyntaxKind.VariableDeclarationList\n    );\n    if (!varDeclarationList) continue;\n    const varDeclaration = varDeclarationList.getFirstChildByKind(SyntaxKind.VariableDeclaration);\n    if (!varDeclaration) continue;\n\n    const schemaName = varDeclaration.getFirstChildByKind(SyntaxKind.Identifier)?.getText();\n    if (!schemaName) continue;\n\n    const modelName = schemaModelMapping[schemaName];\n    if (!modelName) {\n      continue;\n    }\n\n    const newExpression = varDeclaration.getFirstChildByKind(SyntaxKind.NewExpression);\n    if (!newExpression) continue;\n    const objLiteralExp = newExpression.getFirstChildByKind(SyntaxKind.ObjectLiteralExpression);\n    if (!objLiteralExp) continue;\n\n    const extractComments = (objLiteralExp: ObjectLiteralExpression, rootPath: string) => {\n      const propAssignments = objLiteralExp.getChildrenOfKind(SyntaxKind.PropertyAssignment);\n\n      propAssignments.forEach((propAssignment) => {\n        const propName = propAssignment.getFirstChildByKind(SyntaxKind.Identifier)?.getText();\n        if (!propName) return;\n\n        const path = rootPath ? `${rootPath}.${propName}` : propName;\n        propAssignment.getLeadingCommentRanges().forEach((commentRange) => {\n          const commentText = commentRange.getText();\n\n          // skip comments that are not jsdocs\n          if (!commentText.startsWith(\"/**\")) return;\n\n          modelTypes[modelName].comments.push({\n            path,\n            comment: commentText\n          });\n        });\n\n        if (rootPath.split(\".\").length < maxCommentDepth) {\n          const nestedObjLiteralExp = propAssignment.getFirstChildByKind(\n            SyntaxKind.ObjectLiteralExpression\n          );\n          if (nestedObjLiteralExp) {\n            extractComments(nestedObjLiteralExp, path);\n          }\n        }\n      });\n    };\n\n    extractComments(objLiteralExp, \"\");\n  }\n\n  // TODO: get virtual comments\n\n  return modelTypes;\n}\n\nfunction findTypesInFile(sourceFile: SourceFile, modelTypes: TsReaderModelTypes) {\n  const schemaModelMapping: {\n    [schemaVariableName: string]: string;\n  } = {};\n\n  Object.keys(modelTypes).forEach((modelName: string) => {\n    const { schemaVariableName } = modelTypes[modelName];\n    if (schemaVariableName) schemaModelMapping[schemaVariableName] = modelName;\n  });\n\n  for (const statement of sourceFile.getStatements()) {\n    if (!Node.isExpressionStatement(statement)) continue;\n\n    const binaryExpr = statement.getChildAtIndexIfKind(0, SyntaxKind.BinaryExpression);\n    const callExpr = statement.getChildAtIndexIfKind(0, SyntaxKind.CallExpression);\n    if (binaryExpr) {\n      // left is a propertyaccessexpression, children are [identifier, dottoken, identifier]\n      const left = binaryExpr.getLeft();\n      const right = binaryExpr.getRight();\n      if (left.getKind() !== SyntaxKind.PropertyAccessExpression) continue;\n      if (\n        right.getKind() !== SyntaxKind.AsExpression &&\n        right.getKind() !== SyntaxKind.ObjectLiteralExpression &&\n        right.getKind() !== SyntaxKind.TypeAssertionExpression\n      )\n        continue;\n\n      const leftChildren = left.getChildren();\n\n      let modelName: string;\n      const hasSchemaIdentifier = leftChildren.some((child) => {\n        if (child.getKind() !== SyntaxKind.Identifier) return false;\n        modelName = schemaModelMapping[child.getText()];\n        if (!modelName) return false;\n\n        return true;\n      });\n\n      const hasDotToken = leftChildren.some((child) => child.getKind() === SyntaxKind.DotToken);\n      if (!hasSchemaIdentifier || !hasDotToken) continue;\n\n      const hasMethodsIdentifier = leftChildren.some(\n        (child) => child.getKind() === SyntaxKind.Identifier && child.getText() === \"methods\"\n      );\n      const hasStaticsIdentifier = leftChildren.some(\n        (child) => child.getKind() === SyntaxKind.Identifier && child.getText() === \"statics\"\n      );\n      const hasQueryIdentifier = leftChildren.some(\n        (child) => child.getKind() === SyntaxKind.Identifier && child.getText() === \"query\"\n      );\n\n      let rightFuncDeclarations: any[] = [];\n      if (right.getKind() === SyntaxKind.ObjectLiteralExpression) {\n        rightFuncDeclarations = right.getChildrenOfKind(SyntaxKind.MethodDeclaration);\n      } else if (right.getKind() === SyntaxKind.AsExpression) {\n        const objLiteralExp = right.getFirstChildByKind(SyntaxKind.ObjectLiteralExpression);\n        if (objLiteralExp)\n          rightFuncDeclarations = objLiteralExp.getChildrenOfKind(SyntaxKind.MethodDeclaration);\n      } else if (right.getKind() === SyntaxKind.TypeAssertionExpression) {\n        const objLiteralExp = right.getFirstChildByKind(SyntaxKind.ObjectLiteralExpression);\n        if (objLiteralExp) {\n          rightFuncDeclarations = objLiteralExp.getChildrenOfKind(SyntaxKind.MethodDeclaration);\n        }\n      } else {\n        rightFuncDeclarations = right.getChildrenOfKind(SyntaxKind.MethodDeclaration);\n      }\n\n      if (hasMethodsIdentifier) {\n        rightFuncDeclarations.forEach((declaration: MethodDeclaration) => {\n          const { name, type } = getNameAndType(declaration);\n          modelTypes[modelName].methods[name] = type;\n        });\n      } else if (hasStaticsIdentifier) {\n        rightFuncDeclarations.forEach((declaration: MethodDeclaration) => {\n          const { name, type } = getNameAndType(declaration);\n          modelTypes[modelName].statics[name] = type;\n        });\n      } else if (hasQueryIdentifier) {\n        rightFuncDeclarations.forEach((declaration: MethodDeclaration) => {\n          const { name, type } = getNameAndType(declaration);\n          modelTypes[modelName].query[name] = type;\n        });\n      }\n    } else if (callExpr) {\n      // virtual property\n\n      let propAccessExpr = callExpr.getFirstChildByKind(SyntaxKind.PropertyAccessExpression);\n\n      if (propAccessExpr?.getName() === \"set\") {\n        propAccessExpr = propAccessExpr\n          .getFirstChildByKind(SyntaxKind.CallExpression)\n          ?.getFirstChildByKind(SyntaxKind.PropertyAccessExpression);\n      }\n\n      if (propAccessExpr?.getName() !== \"get\") continue;\n\n      const schemaVariableName = propAccessExpr\n        .getFirstChildByKind(SyntaxKind.CallExpression)\n        ?.getFirstChildByKind(SyntaxKind.PropertyAccessExpression)\n        ?.getFirstChildByKind(SyntaxKind.Identifier)\n        ?.getText();\n\n      if (schemaVariableName) {\n        if (process.env.DEBUG)\n          console.log(\"tsreader: Found virtual on schema: \" + schemaVariableName);\n      } else continue;\n\n      const modelName = schemaModelMapping[schemaVariableName];\n      if (!modelName) {\n        if (process.env.DEBUG)\n          console.warn(\n            \"tsreader: Associated model name not found for schema: \" + schemaVariableName\n          );\n        continue;\n      }\n\n      const funcExpr = propAccessExpr\n        ?.getParent()\n        ?.getFirstChildByKind(SyntaxKind.FunctionExpression);\n      const type = funcExpr?.getType()?.getText(funcExpr);\n\n      const callExpr2 = propAccessExpr.getFirstChildByKind(SyntaxKind.CallExpression);\n\n      const stringLiteral = callExpr2?.getArguments()[0];\n      const propAccessExpr2 = callExpr2?.getFirstChildByKind(SyntaxKind.PropertyAccessExpression);\n      if (propAccessExpr2?.getName() !== \"virtual\") {\n        if (process.env.DEBUG) {\n          console.warn(\"tsreader: virtual found on schema does not have virtual initializer\");\n        }\n        continue;\n      }\n\n      const virtualName = stringLiteral?.getText();\n      let returnType = type?.split(\"=> \")?.[1];\n      if (!returnType || !virtualName) {\n        if (process.env.DEBUG)\n          console.warn(\"tsreader: virtualName or returnType not found: \", {\n            virtualName,\n            returnType\n          });\n        continue;\n      }\n\n      /**\n       * @experimental trying this out since certain virtual types are indeterminable and get set to void, which creates incorrect TS errors\n       * This should be a fine workaround because virtual properties shouldn't return solely `void`, they return real values.\n       */\n      if (returnType === \"void\") {\n        if (process.env.DEBUG) {\n          console.warn(\n            \"tsreader: return type found as void, this usually means we couldn't determine the type\"\n          );\n        }\n\n        returnType = \"any\";\n      }\n      const virtualNameSanitized = virtualName.slice(1, virtualName.length - 1);\n\n      modelTypes[modelName].virtuals[virtualNameSanitized] = returnType;\n    }\n  }\n\n  return modelTypes;\n}\n\nconst parseModelInitializer = (\n  d: VariableDeclaration | ExportAssignment,\n  isModelNamedImport: boolean\n) => {\n  const callExpr = d.getFirstChildByKind(SyntaxKind.CallExpression);\n  if (!callExpr) return undefined;\n\n  const callExprStr = callExpr.getText().replace(/[\\r\\n\\t ]/g, \"\");\n\n  // if model is a named import, we can match this without `mongoose.` prefix\n  const pattern = isModelNamedImport\n    ? /model(?:<.+?>)?\\([\"'`](\\w+)[\"'`],(\\w+),?\\)/\n    : /mongoose\\.model(?:<.+?>)?\\([\"'`](\\w+)[\"'`],(\\w+),?\\)/;\n  const modelInitMatch = callExprStr.match(pattern);\n  if (!modelInitMatch) {\n    if (process.env.DEBUG) {\n      console.warn(\n        `tsreader: Could not find model name in Mongoose model initialization: ${callExprStr}`\n      );\n    }\n    return undefined;\n  }\n\n  const [, modelName, schemaVariableName] = modelInitMatch;\n  return { modelName, schemaVariableName };\n};\n\nfunction initModelTypes(sourceFile: SourceFile, filePath: string) {\n  if (process.env.DEBUG) console.log(\"tsreader: Searching file for Mongoose schemas: \" + filePath);\n\n  const modelTypes: TsReaderModelTypes = {};\n  const mongooseImport = sourceFile.getImportDeclaration(\"mongoose\");\n\n  let isModelNamedImport = false;\n  mongooseImport?.getNamedImports().forEach((importSpecifier) => {\n    if (importSpecifier.getText() === \"model\") isModelNamedImport = true;\n  });\n\n  sourceFile.getVariableDeclarations().forEach((d) => {\n    const { modelName, schemaVariableName } = parseModelInitializer(d, isModelNamedImport) ?? {};\n    if (!modelName || !schemaVariableName) return;\n\n    const modelVariableName = d.getName();\n\n    modelTypes[modelName] = {\n      schemaVariableName,\n      modelVariableName,\n      filePath,\n      methods: {},\n      statics: {},\n      query: {},\n      virtuals: {},\n      comments: []\n    };\n  });\n\n  const defaultExportAssignment = sourceFile.getExportAssignment((d) => !d.isExportEquals());\n  if (defaultExportAssignment) {\n    const defaultModelInit = parseModelInitializer(defaultExportAssignment, isModelNamedImport);\n    if (defaultModelInit) {\n      modelTypes[defaultModelInit.modelName] = {\n        schemaVariableName: defaultModelInit.schemaVariableName,\n        filePath,\n        methods: {},\n        statics: {},\n        query: {},\n        virtuals: {},\n        comments: []\n      };\n    }\n  }\n\n  if (process.env.DEBUG) {\n    const schemaNames = Object.keys(modelTypes);\n    if (schemaNames.length === 0)\n      console.warn(\n        `tsreader: No schema found in file. If a schema exists & is exported, it will still be typed but will use generic types for methods, statics, queries & virtuals`\n      );\n    else console.log(\"tsreader: Schemas found: \" + schemaNames);\n  }\n\n  return modelTypes;\n}\n\nexport const getModelTypes = (modelsPaths: string[], maxCommentDepth = 2): TsReaderModelTypes => {\n  const project = new Project({});\n  project.addSourceFilesAtPaths(modelsPaths);\n\n  let allModelTypes: TsReaderModelTypes = {};\n\n  // TODO: ideally we only parse the files that we know have methods, statics, or virtuals.\n  // Would save a lot of time\n  modelsPaths.forEach((modelPath) => {\n    const sourceFile = project.getSourceFileOrThrow(modelPath);\n    let modelTypes = initModelTypes(sourceFile, modelPath);\n\n    modelTypes = findTypesInFile(sourceFile, modelTypes);\n    modelTypes = findCommentsInFile(sourceFile, modelTypes, maxCommentDepth);\n\n    allModelTypes = {\n      ...allModelTypes,\n      ...modelTypes\n    };\n  });\n\n  return allModelTypes;\n};\n\nexport const registerUserTs = async (basePath: string): Promise<(() => void) | null> => {\n  const pathToSearch = basePath.endsWith(\".json\")\n    ? basePath\n    : path.join(basePath, \"**/tsconfig.json\");\n  const files = glob.sync(pathToSearch, { ignore: \"**/node_modules/**\" });\n\n  if (files.length === 0) throw new Error(`No tsconfig.json file found at path \"${basePath}\"`);\n  else if (files.length > 1)\n    throw new Error(\n      `Multiple tsconfig.json files found. Please specify a more specific --project value.\\nPaths found: ${files}`\n    );\n\n  const foundPath = path.join(process.cwd(), files[0]);\n\n  // REMOVE ALL THE TS-NODE REGISTRATION CODE\n  // The loader already handles TypeScript compilation\n\n  // Only handle path aliases\n  try {\n    if (process.env.DEBUG) {\n      console.log(\n        `tsreader: Parsing tsconfig.json at path '${foundPath}' to search for 'paths' field`\n      );\n    }\n    const tsConfig = parseTSConfig(foundPath);\n\n    if (tsConfig?.compilerOptions?.paths) {\n      const baseUrl = path.join(process.cwd(), tsConfig?.compilerOptions?.baseUrl ?? \"\");\n      if (process.env.DEBUG) {\n        console.log(\n          `tsreader: Found 'paths' field in tsconfig.json, registering project with tsconfig-paths using baseUrl '${baseUrl}'`\n        );\n      }\n\n      const { register: registerPaths } = await import(\"tsconfig-paths\");\n      const cleanup = registerPaths({\n        baseUrl,\n        paths: tsConfig.compilerOptions.paths\n      });\n\n      if (process.env.DEBUG) {\n        console.log(\"tsreader: tsconfig-paths registered\");\n      }\n\n      return cleanup;\n    }\n\n    return null;\n  } catch (err) {\n    throw new Error(`Error parsing your tsconfig.json file: ${(err as Error).message}`);\n  }\n};\n\nexport function parseTSConfig(tsconfigFilePath: string) {\n  const tsConfigString = fs.readFileSync(tsconfigFilePath, \"utf8\");\n\n  const tsConfig = JSON.parse(stripJsonComments(tsConfigString));\n\n  // Handle the case where the tsconfig.json file has a \"extends\" property\n  if (tsConfig.extends) {\n    // Resolve the path to the extended tsconfig.json file\n    const extendedPath = resolve.sync(tsConfig.extends, {\n      basedir: path.dirname(tsconfigFilePath)\n    });\n\n    // Read and merge paths from the extended tsconfig.json recursively\n    const extendedConfig = parseTSConfig(extendedPath);\n    // Merge paths from extendedConfig into tsConfig\n    tsConfig.compilerOptions.paths = {\n      ...extendedConfig.compilerOptions.paths,\n      ...tsConfig.compilerOptions.paths\n    };\n\n    // We only want to set the base URL if its not already set, since the child tsconfig should always overwrite extended tsconfigs.\n    // So the first child we find with a base URL be the final base URL\n    if (extendedConfig.compilerOptions.baseUrl && !tsConfig.compilerOptions.baseUrl) {\n      tsConfig.compilerOptions.baseUrl = extendedConfig.compilerOptions.baseUrl;\n    }\n  }\n\n  return tsConfig;\n}\n","import glob from \"glob\";\r\nimport path from \"path\";\r\nimport * as fs from \"fs\";\r\n\r\nexport const getConfigFromFile = (configPath?: string): Record<string, unknown> => {\r\n  // if no path provided, check root path for mtgen.config.json file. If doesnt exist, return empty object.\r\n  if (!configPath) {\r\n    const defaultPath = path.join(process.cwd(), \"mtgen.config.json\");\r\n    if (glob.sync(defaultPath).length === 0) return {};\r\n\r\n    configPath = defaultPath;\r\n  }\r\n\r\n  const { dir, base } = path.parse(configPath);\r\n\r\n  if (!base) configPath = path.join(dir, \"mtgen.config.json\");\r\n  else if (base !== \"mtgen.config.json\") {\r\n    throw new Error(\r\n      `${base} is not a valid config filename. Ensure to provide a path to a mtgen.config.json file or its parent folder.`\r\n    );\r\n  }\r\n\r\n  const rawConfig = fs.readFileSync(configPath, \"utf8\");\r\n  return JSON.parse(rawConfig);\r\n};\r\n\r\nexport const getModelsPaths = (basePath?: string): string[] => {\r\n  let modelsPaths: string[];\r\n  if (basePath && basePath !== \"\") {\r\n    // base path, only check that path\r\n    const { ext } = path.parse(basePath);\r\n\r\n    // if path points to a folder, search for ts files in folder.\r\n    const modelsFolderPath = ext === \"\" ? path.join(basePath, \"*.ts\") : basePath;\r\n\r\n    modelsPaths = glob.sync(modelsFolderPath, {\r\n      ignore: \"**/node_modules/**\"\r\n    });\r\n\r\n    if (modelsPaths.length === 0) {\r\n      throw new Error(`No model files found found at path \"${basePath}\".`);\r\n    }\r\n\r\n    // Put any index files at the end of the array. This ensures that if an index.ts file re-exports models, the parser\r\n    // picks up the models from the individual files and not the index.ts file so that the tsReader will also pick them up properly\r\n    modelsPaths.sort((_a, b) => (b.endsWith(\"index.ts\") ? -1 : 0));\r\n  } else {\r\n    // no base path, recursive search files in a `models/` folder\r\n    const modelsFolderPath = `**/models/!(index).ts`;\r\n\r\n    modelsPaths = glob.sync(modelsFolderPath, {\r\n      ignore: \"**/node_modules/**\"\r\n    });\r\n\r\n    if (modelsPaths.length === 0) {\r\n      throw new Error(\r\n        `Recursive search could not find any model files at \"**/models/!(index).ts\". Please provide a path to your models folder.`\r\n      );\r\n    }\r\n  }\r\n\r\n  return modelsPaths.map((filename: string) => path.join(process.cwd(), filename));\r\n};\r\n\r\nexport const cleanOutputPath = (outputPath: string) => {\r\n  const { dir, base, ext } = path.parse(outputPath);\r\n\r\n  // if `ext` is not empty (meaning outputPath references a file and not a directory) and `ext` != \".ts\", means user provided an ivalid filetype (must be a `.ts` file to support typescript interfaces and types)/\r\n  if (ext !== \"\" && ext !== \".ts\") {\r\n    throw new Error(\r\n      \"Invalid --ouput argument. Please provide either a folder pah or a Typescript file path.\"\r\n    );\r\n  }\r\n\r\n  // if extension is empty, means a folder path was provided. Join dir and base to create that path. If filepath was passed, sets to enclosing folder.\r\n  const folderPath = ext === \"\" ? path.join(dir, base) : dir;\r\n  const genFileName = ext === \"\" ? \"mongoose.gen.ts\" : base;\r\n\r\n  return path.join(folderPath, genFileName);\r\n};\r\n","import fs from \"fs\";\r\nimport prettier from \"prettier\";\r\n\r\n// I removed ESLINT usage since it doesnt seem to add much value and adds room for bugs.\r\n// If we want to re-add it, we need to add a check to ensure someone has an eslint config before linting files\r\n// and set eslint as an optional dependency\r\n\r\n// import { ESLint } from \"eslint\";\r\n\r\n// NOTE: this could be sped up by formatting the generated file string prior to writing (no need to write file then read it again here and re-write it)\r\nconst prettifyFiles = (filePaths: string[]) => {\r\n  const config =\r\n    prettier.resolveConfig.sync(process.cwd(), { useCache: true, editorconfig: true }) ?? {};\r\n\r\n  filePaths.forEach((filePath: string) => {\r\n    const ogContent = fs.readFileSync(filePath);\r\n    const formattedContent = prettier.format(ogContent.toString(), {\r\n      ...config,\r\n      parser: \"typescript\"\r\n    });\r\n    fs.writeFileSync(filePath, formattedContent);\r\n  });\r\n};\r\n\r\n// const fixFiles = async (_filePaths: string[]) => {\r\n// const eslint = new ESLint({ fix: true });\r\n// const results = await eslint.lintFiles(filePaths);\r\n// await ESLint.outputFixes(results);\r\n// };\r\n\r\nexport const format = async (filePaths: string[]) => {\r\n  prettifyFiles(filePaths);\r\n  // await fixFiles(filePaths);\r\n};\r\n","export const MAIN_HEADER = `/* tslint:disable */\\n/* eslint-disable */\\n\\n// ######################################## THIS FILE WAS GENERATED BY MONGOOSE-TSGEN ######################################## //\\n\\n// NOTE: ANY CHANGES MADE WILL BE OVERWRITTEN ON SUBSEQUENT EXECUTIONS OF MONGOOSE-TSGEN.`;\r\nexport const MONGOOSE_IMPORT = `import mongoose from \"mongoose\";`;\r\n\r\nexport const POPULATE_HELPERS = `/**\r\n * Check if a property on a document is populated:\r\n * \\`\\`\\`\r\n * import { IsPopulated } from \"../interfaces/mongoose.gen.ts\"\r\n * \r\n * if (IsPopulated<UserDocument[\"bestFriend\"]>) { ... }\r\n * \\`\\`\\`\r\n */\r\nexport function IsPopulated<T>(doc: T | mongoose.Types.ObjectId): doc is T {\r\n  return doc instanceof mongoose.Document;\r\n}\r\n\r\n/**\r\n * Helper type used by \\`PopulatedDocument\\`. Returns the parent property of a string \r\n * representing a nested property (i.e. \\`friend.user\\` -> \\`friend\\`)\r\n */\r\ntype ParentProperty<T> = T extends \\`\\${infer P}.\\${string}\\` ? P : never;\r\n\r\n/**\r\n* Helper type used by \\`PopulatedDocument\\`. Returns the child property of a string \r\n* representing a nested property (i.e. \\`friend.user\\` -> \\`user\\`).\r\n*/\r\ntype ChildProperty<T> = T extends \\`\\${string}.\\${infer C}\\` ? C : never;\r\n\r\n/**\r\n* Helper type used by \\`PopulatedDocument\\`. Removes the \\`ObjectId\\` from the general union type generated \r\n* for ref documents (i.e. \\`mongoose.Types.ObjectId | UserDocument\\` -> \\`UserDocument\\`)\r\n*/\r\ntype PopulatedProperty<Root, T extends keyof Root> = Omit<Root, T> & { \r\n  [ref in T]: Root[T] extends mongoose.Types.Array<infer U> ? \r\n    mongoose.Types.Array<Exclude<U, mongoose.Types.ObjectId>> :\r\n    Exclude<Root[T], mongoose.Types.ObjectId> \r\n}\r\n\r\n/**\r\n * Populate properties on a document type:\r\n * \\`\\`\\`\r\n * import { PopulatedDocument } from \"../interfaces/mongoose.gen.ts\"\r\n *\r\n * function example(user: PopulatedDocument<UserDocument, \"bestFriend\">) {\r\n *   console.log(user.bestFriend._id) // typescript knows this is populated\r\n * }\r\n * \\`\\`\\`\r\n */\r\nexport type PopulatedDocument<\r\nDocType,\r\nT\r\n> = T extends keyof DocType\r\n? PopulatedProperty<DocType, T> \r\n: (\r\n    ParentProperty<T> extends keyof DocType\r\n      ? Omit<DocType, ParentProperty<T>> &\r\n      {\r\n        [ref in ParentProperty<T>]: (\r\n          DocType[ParentProperty<T>] extends mongoose.Types.Array<infer U> ? (\r\n            mongoose.Types.Array<\r\n              ChildProperty<T> extends keyof U \r\n                ? PopulatedProperty<U, ChildProperty<T>> \r\n                : PopulatedDocument<U, ChildProperty<T>>\r\n            >\r\n          ) : (\r\n            ChildProperty<T> extends keyof DocType[ParentProperty<T>]\r\n            ? PopulatedProperty<DocType[ParentProperty<T>], ChildProperty<T>>\r\n            : PopulatedDocument<DocType[ParentProperty<T>], ChildProperty<T>>\r\n          )\r\n        )\r\n      }\r\n      : DocType\r\n  )\r\n\r\n`;\r\n\r\nexport const QUERY_POPULATE = `/**\r\n * Helper types used by the populate overloads\r\n */\r\ntype Unarray<T> = T extends Array<infer U> ? U : T;\r\ntype Modify<T, R> = Omit<T, keyof R> & R;\r\n\r\n/**\r\n * Augment mongoose with Query.populate overloads\r\n */\r\ndeclare module \"mongoose\" {\r\n  interface Query<ResultType, DocType, THelpers = {}> {\r\n    populate<T extends string>(path: T, select?: string | any, model?: string | Model<any, THelpers>, match?: any): Query<\r\n      ResultType extends Array<DocType> ? Array<PopulatedDocument<Unarray<ResultType>, T>> : (ResultType extends DocType ? PopulatedDocument<Unarray<ResultType>, T> : ResultType),\r\n      DocType,\r\n      THelpers\r\n    > & THelpers;\r\n\r\n    populate<T extends string>(options: Modify<PopulateOptions, { path: T }> | Array<PopulateOptions>): Query<\r\n      ResultType extends Array<DocType> ? Array<PopulatedDocument<Unarray<ResultType>, T>> : (ResultType extends DocType ? PopulatedDocument<Unarray<ResultType>, T> : ResultType),\r\n      DocType,\r\n      THelpers\r\n    > & THelpers;\r\n  }\r\n}`;\r\n\r\nexport const getObjectDocs = (modelName: string) => `/**\r\n * Lean version of ${modelName}Document (type alias of \\`${modelName}\\`)\r\n * \r\n * Use this type alias to avoid conflicts with model names:\r\n * \\`\\`\\`\r\n * import { ${modelName} } from \"../models\"\r\n * import { ${modelName}Object } from \"../interfaces/mongoose.gen.ts\"\r\n * \r\n * const ${modelName.toLowerCase()}Object: ${modelName}Object = ${modelName.toLowerCase()}.toObject();\r\n * \\`\\`\\`\r\n */`;\r\n\r\nexport const getQueryDocs = () => `/**\r\n * Mongoose Query type\r\n * \r\n * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.\r\n */`;\r\n\r\nexport const getQueryHelpersDocs = (modelName: string) => `/**\r\n * Mongoose Query helper types\r\n * \r\n * This type represents \\`${modelName}Schema.query\\`. For most use cases, you should not need to use this type explicitly.\r\n */`;\r\n\r\nexport const getModelDocs = (modelName: string) => `/**\r\n * Mongoose Model type\r\n * \r\n * Pass this type to the Mongoose Model constructor:\r\n * \\`\\`\\`\r\n * const ${modelName} = mongoose.model<${modelName}Document, ${modelName}Model>(\"${modelName}\", ${modelName}Schema);\r\n * \\`\\`\\`\r\n */`;\r\n\r\nexport const getDocumentDocs = (modelName: string) => `/**\r\n * Mongoose Document type\r\n * \r\n * Pass this type to the Mongoose Model constructor:\r\n * \\`\\`\\`\r\n * const ${modelName} = mongoose.model<${modelName}Document, ${modelName}Model>(\"${modelName}\", ${modelName}Schema);\r\n * \\`\\`\\`\r\n */`;\r\n\r\nexport const getSchemaDocs = (modelName: string) => `/**\r\n * Mongoose Schema type\r\n * \r\n * Assign this type to new ${modelName} schema instances:\r\n * \\`\\`\\`\r\n * const ${modelName}Schema: ${modelName}Schema = new mongoose.Schema({ ... })\r\n * \\`\\`\\`\r\n */`;\r\n\r\n// If model is a subdoc, pass `fullName`\r\nexport const getLeanDocs = (modelName: string, fullName?: string) => `/**\r\n * Lean version of ${fullName ?? modelName}Document\r\n * \r\n * This has all Mongoose getters & functions removed. This type will be returned from \\`${modelName}Document.toObject()\\`.${\r\n  !fullName || modelName === fullName ?\r\n    ` To avoid conflicts with model names, use the type alias \\`${modelName}Object\\`.` :\r\n    \"\"\r\n}\r\n * \\`\\`\\`\r\n * const ${modelName.toLowerCase()}Object = ${modelName.toLowerCase()}.toObject();\r\n * \\`\\`\\`\r\n */`;\r\n\r\nexport const getSubdocumentDocs = (modelName: string, path: string) => `/**\r\n * Mongoose Subdocument type\r\n * \r\n * Type of \\`${modelName}Document[\"${path}\"]\\` element.\r\n */`;\r\n","/**\r\n * TypeScript keywords categorized by their usage context. (where I got the list)\r\n * @see {@link https://github.com/microsoft/TypeScript/issues/2536 TS Reserved Words}\r\n */\r\n\r\n/**\r\n * Regular JavaScript/TypeScript reserved words that cannot be used as identifiers in any context.\r\n * These are the core keywords that form the basic syntax and control flow of the language.\r\n * Using these as identifiers will always result in a syntax error.\r\n *\r\n * @example\r\n * // These will cause syntax errors:\r\n * type if = string;    // Error: 'if' is a reserved word\r\n * interface class {}   // Error: 'class' is a reserved word\r\n */\r\nexport const tsReservedWords = [\r\n  \"break\",\r\n  \"case\",\r\n  \"catch\",\r\n  \"class\",\r\n  \"const\",\r\n  \"continue\",\r\n  \"debugger\",\r\n  \"default\",\r\n  \"delete\",\r\n  \"do\",\r\n  \"else\",\r\n  \"enum\",\r\n  \"export\",\r\n  \"extends\",\r\n  \"false\",\r\n  \"finally\",\r\n  \"for\",\r\n  \"function\",\r\n  \"if\",\r\n  \"import\",\r\n  \"in\",\r\n  \"instanceof\",\r\n  \"new\",\r\n  \"null\",\r\n  \"return\",\r\n  \"super\",\r\n  \"switch\",\r\n  \"this\",\r\n  \"throw\",\r\n  \"true\",\r\n  \"try\",\r\n  \"typeof\",\r\n  \"var\",\r\n  \"void\",\r\n  \"while\",\r\n  \"with\"\r\n] as const;\r\n\r\n/**\r\n * Additional reserved words that include both JavaScript strict mode keywords\r\n * and TypeScript-specific modifiers. These cannot be used as identifiers in\r\n * strict mode or when using TypeScript features.\r\n *\r\n * @example\r\n * // These will cause errors:\r\n * let interface = \"foo\";     // Error: 'interface' is reserved\r\n */\r\nexport const tsStrictModeReservedWords = [\r\n  \"as\",\r\n  \"implements\",\r\n  \"interface\",\r\n  \"let\",\r\n  \"package\",\r\n  \"private\",\r\n  \"protected\",\r\n  \"public\",\r\n  \"static\",\r\n  \"yield\"\r\n] as const;\r\n\r\n/**\r\n * Contextual keywords that have special meaning in certain contexts but can be used as identifiers.\r\n * These keywords need to be handled carefully during type generation to avoid creating invalid TypeScript.\r\n *\r\n * @example\r\n * // These would create invalid type definitions:\r\n * type type = string;        // Error: 'type' is a contextual keyword\r\n * interface get<T> {}        // Error: 'get' cannot be used as an interface name\r\n * type async<T> = T;        // Error: 'async' cannot be used as a type alias\r\n */\r\nexport const tsContextualKeywords = [\r\n  \"any\",\r\n  \"async\",\r\n  \"await\",\r\n  \"boolean\",\r\n  \"constructor\",\r\n  \"declare\",\r\n  \"get\",\r\n  \"infer\",\r\n  \"is\",\r\n  \"keyof\",\r\n  \"module\",\r\n  \"namespace\",\r\n  \"never\",\r\n  \"readonly\",\r\n  \"require\",\r\n  \"number\",\r\n  \"set\",\r\n  \"string\",\r\n  \"symbol\",\r\n  \"type\",\r\n  \"from\",\r\n  \"of\",\r\n  \"unknown\",\r\n  \"undefined\",\r\n  \"unique\",\r\n  \"global\"\r\n] as const;\r\n\r\n/**\r\n * Combined array of all TypeScript keywords, including reserved words,\r\n * strict mode reserved words, and contextual keywords.\r\n * This comprehensive list can be used when checking if a string is any kind\r\n * of TypeScript keyword.\r\n */\r\nexport const tsReservedKeywords = [\r\n  ...tsReservedWords,\r\n  ...tsStrictModeReservedWords,\r\n  ...tsContextualKeywords\r\n] as const;\r\n\r\n/**\r\n * Regex pattern that matches any character that is not a valid TypeScript identifier character.\r\n * Used to split strings into parts that could form valid identifiers.\r\n * Valid characters are: a-z, A-Z, 0-9, underscore (_), and dollar sign ($)\r\n */\r\nexport const TS_IDENTIFIER_SEPARATOR_REGEX = /[^a-zA-Z0-9_$]+/;\r\n\r\n/**\r\n * Regex pattern that matches invalid TypeScript identifier characters.\r\n * Used to clean individual parts of an identifier.\r\n * Matches anything that is not: a-z, A-Z, 0-9, underscore (_), or dollar sign ($)\r\n */\r\nexport const TS_INVALID_CHAR_REGEX = /[^a-zA-Z0-9_$]/g;\r\n\r\n/**\r\n * Regex pattern that matches invalid starting characters for TypeScript identifiers.\r\n * Used to ensure the first part of an identifier starts with a valid character.\r\n * Matches any characters that are not: a-z, A-Z, underscore (_), or dollar sign ($)\r\n */\r\nexport const TS_INVALID_START_REGEX = /^[^a-zA-Z_$]+/;\r\n","import { tsReservedKeywords } from \"../helpers/constants\";\r\n\r\nexport const convertKeyValueToLine = ({\r\n  key,\r\n  valueType,\r\n  isOptional = false,\r\n  newline = true\r\n}: {\r\n  key: string;\r\n  valueType: string;\r\n  isOptional?: boolean;\r\n  newline?: boolean;\r\n}) => {\r\n  let line = \"\";\r\n\r\n  if (key) {\r\n    // Check if the key is a valid TypeScript identifier:\r\n    // 1. Must start with a letter, underscore, or dollar sign\r\n    // 2. Can contain letters, numbers, underscores, or dollar signs\r\n    // 3. Cannot be a reserved keyword\r\n    const isValidTsIdentifier =\r\n      /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) && !tsReservedKeywords.includes(key as any);\r\n\r\n    line += isValidTsIdentifier ? key : JSON.stringify(key);\r\n\r\n    if (isOptional) line += \"?\";\r\n    line += \": \";\r\n  }\r\n\r\n  line += valueType + \";\";\r\n  if (newline) line += \"\\n\";\r\n  return line;\r\n};\r\n","import mongoose from \"mongoose\";\nimport _ from \"lodash\";\nimport pluralize from \"pluralize\";\nimport { MongooseModel } from \"./types\";\nimport { convertKeyValueToLine } from \"../writer/stringBuilder\";\nimport { pathToFileURL } from \"url\";\n\nexport const getSubdocName = (path: string, modelName = \"\") => {\n  let subDocName =\n    modelName +\n    path\n      .split(\".\")\n      .map((p: string) => p[0].toUpperCase() + p.slice(1))\n      .join(\"\");\n\n  subDocName = pluralize.singular(subDocName);\n\n  // // If a user names a field \"model\", it will conflict with the model name, so we need to rename it.\n  // // https://github.com/francescov1/mongoose-tsgen/issues/128\n  if (subDocName === `${modelName}Model`) {\n    // NOTE: This wasnt behavior for usage from getTypeFromKeyValue, but it should probably be here anyways.\n    // If causes issues, add a param to control it\n    subDocName += \"Field\";\n  }\n\n  return subDocName;\n};\n\nexport const isMapType = (val: any): boolean => {\n  return val === Map || val === mongoose.Schema.Types.Map;\n};\n\nexport const convertBaseTypeToTs = ({\n  key,\n  val,\n  isDocument,\n  noMongoose,\n  datesAsStrings\n}: {\n  key: string;\n  val: any;\n  isDocument: boolean;\n  noMongoose: boolean;\n  datesAsStrings: boolean;\n}) => {\n  // NOTE: ideally we check actual type of value to ensure its Schema.Types.Mixed (the same way we do with Schema.Types.ObjectId),\n  // but this doesnt seem to work for some reason\n  // {} is treated as Mixed\n  if (\n    val.schemaName === \"Mixed\" ||\n    val.type?.schemaName === \"Mixed\" ||\n    (val.constructor === Object && _.isEmpty(val)) ||\n    (val.type?.constructor === Object && _.isEmpty(val.type))\n  ) {\n    return \"any\";\n  }\n\n  const isMap = isMapType(val.type);\n  const mongooseType = isMap ? val.of : val.type;\n\n  // If the user specifies a map with no type, we set to any\n  if (isMap && !mongooseType) {\n    return \"any\";\n  }\n\n  switch (mongooseType) {\n    case mongoose.Schema.Types.String:\n    case String:\n    case \"String\":\n      // NOTE: This handles the `enum` field being both an array of values and being a TS enum (so that we can support this feature: https://github.com/Automattic/mongoose/issues/9546)\n      if (val.enum && Object.values(val.enum)?.length > 0) {\n        // User passed a typescript enum to the enum property of the String field config.\n        const enumValues = Object.values(val.enum);\n\n        const includesNull = enumValues.includes(null);\n        const enumValuesWithoutNull = enumValues.filter((str) => str !== null);\n        let enumTypscriptType = `\"` + enumValuesWithoutNull.join(`\" | \"`) + `\"`;\n        if (includesNull) enumTypscriptType += ` | null`;\n        return enumTypscriptType;\n      }\n\n      return \"string\";\n    case mongoose.Schema.Types.Number:\n    case Number:\n    case \"Number\":\n      return key === \"__v\" ? undefined : \"number\";\n    case mongoose.Schema.Types.Decimal128:\n    case mongoose.Types.Decimal128:\n      return isDocument ? \"mongoose.Types.Decimal128\" : \"number\";\n    case mongoose.Schema.Types.Boolean:\n    case Boolean:\n    case \"Boolean\":\n      return \"boolean\";\n    case mongoose.Schema.Types.Date:\n    case Date:\n    case \"Date\":\n      return datesAsStrings ? \"string\" : \"Date\";\n    case mongoose.Types.Buffer:\n    case mongoose.Schema.Types.Buffer:\n    case Buffer:\n    case \"Buffer\":\n      return isDocument ? \"mongoose.Types.Buffer\" : \"Buffer\";\n    case mongoose.Schema.Types.ObjectId:\n    case mongoose.Types.ObjectId:\n    case \"ObjectId\": // _id fields have type set to the string \"ObjectId\"\n      return noMongoose ? \"string\" : \"mongoose.Types.ObjectId\";\n    case Object:\n      return \"any\";\n    default:\n      if (_.isPlainObject(val)) {\n        // This indicates to the parent func that this type is nested and we need to traverse one level deeper\n        return \"{}\";\n      }\n\n      console.warn(\n        `parser: Unknown type detected for field \"${key}\", using type \"any\". Please create an issue in the mongoose-tsgen GitHub repo to have this case handled.`\n      );\n\n      return \"any\";\n  }\n};\n\nexport const getShouldLeanIncludeVirtuals = (schema: any) => {\n  // Check the toObject options to determine if virtual property should be included.\n  // See https://mongoosejs.com/docs/api.html#document_Document-toObject for toObject option documentation.\n  const toObjectOptions = schema.options?.toObject ?? {};\n  if (\n    (!toObjectOptions.virtuals && !toObjectOptions.getters) ||\n    (toObjectOptions.virtuals === false && toObjectOptions.getters === true)\n  )\n    return false;\n  return true;\n};\n\nexport const BASE_TYPES = new Set([\n  Object,\n  String,\n  \"String\",\n  Number,\n  \"Number\",\n  Boolean,\n  \"Boolean\",\n  Date,\n  \"Date\",\n  Buffer,\n  \"Buffer\",\n  Map,\n  mongoose.Schema.Types.String,\n  mongoose.Schema.Types.Number,\n  mongoose.Schema.Types.Boolean,\n  mongoose.Schema.Types.Date,\n  mongoose.Schema.Types.Map,\n  mongoose.Types.Buffer,\n  mongoose.Schema.Types.Buffer,\n  mongoose.Schema.Types.ObjectId,\n  mongoose.Types.ObjectId,\n  mongoose.Types.Decimal128,\n  mongoose.Schema.Types.Decimal128\n]);\n\nexport const loadModels = async (modelsPaths: string[]): Promise<MongooseModel[]> => {\n  const nameToModelMap: { [modelName: string]: MongooseModel } = {};\n\n  const checkAndRegisterModel = (obj: any): boolean => {\n    if (!obj?.modelName || !obj?.schema) return false;\n    nameToModelMap[obj.modelName] = obj;\n    return true;\n  };\n\n  // Change from forEach to for...of\n  for (const singleModelPath of modelsPaths) {\n    let exportedData;\n    try {\n      if (process.env.DEBUG) {\n        console.log(\"parser: Attempting to import model from path: \" + singleModelPath);\n      }\n\n      exportedData = await import(pathToFileURL(singleModelPath).href);\n\n      if (process.env.DEBUG) {\n        console.log(\"parser: Successfully imported:\", Object.keys(exportedData));\n      }\n    } catch (err) {\n      const error = (err as Error).message?.includes(`Cannot find module '${singleModelPath}'`)\n        ? new Error(`Could not find a module at path ${singleModelPath}.`)\n        : err;\n      throw error;\n    }\n\n    const prevSchemaCount = Object.keys(nameToModelMap).length;\n\n    checkAndRegisterModel(exportedData);\n\n    for (const obj of Object.values(exportedData)) {\n      checkAndRegisterModel(obj);\n    }\n\n    const schemaCount = Object.keys(nameToModelMap).length - prevSchemaCount;\n    if (schemaCount === 0) {\n      console.warn(\n        `A module was found at ${singleModelPath}, but no new exported models were found. If this file contains a Mongoose schema, ensure it is exported and its name does not conflict with others.`\n      );\n    }\n  }\n\n  return Object.values(nameToModelMap);\n};\n\n// TODO: This is one of the most complex functions, and should be refactored.\n// TODO: May want to splti up the string building with the type extraction\nexport const getTypeFromKeyValue = ({\n  key,\n  val: valOriginal,\n  isDocument,\n  shouldLeanIncludeVirtuals,\n  noMongoose,\n  datesAsStrings\n}: {\n  key: string;\n  val: any;\n  isDocument: boolean;\n  shouldLeanIncludeVirtuals: boolean;\n  noMongoose: boolean;\n  datesAsStrings: boolean;\n}): string => {\n  // if the value is an object, we need to deepClone it to ensure changes to `val` aren't persisted in parent function\n  let val = _.isPlainObject(valOriginal) ? _.cloneDeep(valOriginal) : valOriginal;\n  let valueType: string | undefined;\n\n  const requiredValue = Array.isArray(val.required) ? val.required[0] : val.required;\n  let isOptional = requiredValue !== true;\n\n  let isArray = Array.isArray(val);\n  let isUntypedArray = false;\n  let isMapOfArray = false;\n  /**\n   * If _isDefaultSetToUndefined is set, it means this is a subdoc array with `default: undefined`, indicating that mongoose will not automatically\n   * assign an empty array to the value. Therefore, isOptional = true. In other cases, isOptional is false since the field will be automatically initialized\n   * with an empty array\n   */\n  const isArrayOuterDefaultSetToUndefined = Boolean(val._isDefaultSetToUndefined);\n\n  // this means its a subdoc\n  if (isArray) {\n    val = val[0];\n    if (val === undefined && val?.type === undefined) {\n      isUntypedArray = true;\n      isOptional = isArrayOuterDefaultSetToUndefined ?? false;\n    } else {\n      isOptional = val._isDefaultSetToUndefined ?? false;\n    }\n\n    // Array optionality is a bit overcomplicated, see https://github.com/francescov1/mongoose-tsgen/issues/124.\n    // If user explicitely sets required: false, we override our logic and assume they know best.\n    if (requiredValue === false) {\n      isOptional = true;\n    }\n  } else if (Array.isArray(val.type)) {\n    val.type = val.type[0];\n    isArray = true;\n\n    if (val.type === undefined) {\n      isUntypedArray = true;\n      isOptional = isArrayOuterDefaultSetToUndefined ?? false;\n    } else if (val.type.type) {\n      /**\n       * Arrays can also take the following format.\n       * This is used when validation needs to be done on both the element itself and the full array.\n       * This format implies `required: true`.\n       *\n       * ```\n       * friends: {\n       *   type: [\n       *     {\n       *       type: Schema.Types.ObjectId,\n       *       ref: \"User\",\n       *       validate: [\n       *         function(userId: mongoose.Types.ObjectId) { return !this.friends.includes(userId); }\n       *       ]\n       *     }\n       *   ],\n       *   validate: [function(val) { return val.length <= 3; } ]\n       * }\n       * ```\n       */\n      if (val.type.ref) val.ref = val.type.ref;\n      val.type = val.type.type;\n      isOptional = false;\n    } else if (val.index === \"2dsphere\") {\n      // 2dsphere index is a special edge case which does not have an inherent default value of []\n      isOptional = true;\n    } else if (\"default\" in val && val.default === undefined && requiredValue !== true) {\n      // If default: undefined, it means the field should not default with an empty array.\n      isOptional = true;\n    } else {\n      isOptional = isArrayOuterDefaultSetToUndefined;\n    }\n\n    // Array optionality is a bit overcomplicated, see https://github.com/francescov1/mongoose-tsgen/issues/124.\n    // If user explicitely sets required: false, we override our logic and assume they know best.\n    if (requiredValue === false) {\n      isOptional = true;\n    }\n  }\n\n  if (BASE_TYPES.has(val)) val = { type: val };\n\n  const isMap = isMapType(val?.type);\n\n  // // handles maps of arrays as per https://github.com/francescov1/mongoose-tsgen/issues/63\n  if (isMap && Array.isArray(val.of)) {\n    val.of = val.of[0];\n    isMapOfArray = true;\n    isArray = true;\n  }\n\n  if (val === Array || val?.type === Array || isUntypedArray) {\n    // treat Array constructor and [] as an Array<Mixed>\n    isArray = true;\n    valueType = \"any\";\n    isOptional = isArrayOuterDefaultSetToUndefined ?? false;\n\n    // Array optionality is a bit overcomplicated, see https://github.com/francescov1/mongoose-tsgen/issues/124.\n    // If user explicitely sets required: false, we override our logic and assume they know best.\n    if (requiredValue === false) {\n      isOptional = true;\n    }\n  } else if (val._inferredInterfaceName) {\n    valueType = val._inferredInterfaceName + (isDocument ? \"Document\" : \"\");\n  } else if (isMap && val.of?._inferredInterfaceName) {\n    valueType = val.of._inferredInterfaceName + (isDocument ? \"Document\" : \"\");\n    isOptional = val.of.required !== true;\n  } else if (val.path && val.path && val.setters && val.getters) {\n    // check for virtual properties\n    // skip id property\n    if (key === \"id\") return \"\";\n\n    // if not lean doc and lean docs shouldnt include virtuals, ignore entry\n    if (!isDocument && !shouldLeanIncludeVirtuals) return \"\";\n    // If the val has the _aliasRootField property, it means this field is an alias for another field, and _aliasRootField contains the other field's type.\n    // So we can re-call this function using _aliasRootField.\n    if (val._aliasRootField) {\n      return getTypeFromKeyValue({\n        key,\n        val: val._aliasRootField,\n        isDocument,\n        shouldLeanIncludeVirtuals,\n        noMongoose,\n        datesAsStrings\n      });\n    }\n\n    valueType = \"any\";\n    isOptional = false;\n  } else if (\n    key &&\n    [\n      \"get\",\n      \"set\",\n      \"schemaName\",\n      \"_defaultCaster\",\n      \"defaultOptions\",\n      \"_checkRequired\",\n      \"_cast\",\n      \"checkRequired\",\n      \"cast\",\n      \"__v\"\n    ].includes(key)\n  ) {\n    return \"\";\n  } else if (val.ref) {\n    let docRef = val.ref.replace?.(`'`, \"\");\n\n    if (typeof val.ref === \"function\") {\n      if (noMongoose) {\n        valueType = \"string\";\n      } else {\n        // If we get a function, we cant determine the document that we would populate, so just assume it's an ObjectId\n        valueType = \"mongoose.Types.ObjectId\";\n\n        // If generating the document version, we can also provide document as an option to reflect the populated case. But for\n        // lean docs we can't do this cause we don't have a base type to extend from (since we can't determine it when parsing only JS).\n        // Later the tsReader can implement a function typechecker to subtitute the type with the more exact one.\n        if (isDocument) {\n          valueType += \" | mongoose.Document\";\n        }\n      }\n    } else if (docRef) {\n      // If val.ref is an invalid type (not a string) then this gets skipped.\n      if (docRef.includes(\".\")) {\n        docRef = getSubdocName(docRef);\n      }\n\n      const populatedType = isDocument ? `${docRef}Document` : docRef;\n      valueType = val.autopopulate // support for mongoose-autopopulate\n        ? populatedType\n        : `${populatedType}[\"_id\"] | ${populatedType}`;\n    }\n  } else {\n    // _ids are always required\n    if (key === \"_id\") isOptional = false;\n\n    const convertedType = convertBaseTypeToTs({\n      key,\n      val,\n      isDocument,\n      noMongoose,\n      datesAsStrings\n    });\n\n    // TODO: we should detect nested types from unknown types and handle differently.\n    // Currently, if we get an unknown type (ie not handled) then users run into a \"max callstack exceeded error\"\n    if (convertedType === \"{}\") {\n      const nestedSchema = _.cloneDeep(val);\n      valueType = \"{\\n\";\n\n      Object.keys(nestedSchema).forEach((key: string) => {\n        valueType += getTypeFromKeyValue({\n          key,\n          val: nestedSchema[key],\n          isDocument,\n          shouldLeanIncludeVirtuals,\n          noMongoose,\n          datesAsStrings\n        });\n      });\n\n      valueType += \"}\";\n      isOptional = false;\n    } else {\n      valueType = convertedType;\n    }\n  }\n\n  if (!valueType) return \"\";\n\n  if (isMap && !isMapOfArray)\n    valueType = isDocument ? `mongoose.Types.Map<${valueType}>` : `Map<string, ${valueType}>`;\n\n  if (isArray) {\n    if (isDocument)\n      valueType = `mongoose.Types.${val._isSubdocArray ? \"Document\" : \"\"}Array<` + valueType + \">\";\n    else {\n      // if valueType includes a space, likely means its a union type (ie \"number | string\") so lets wrap it in brackets when adding the array to the type\n      if (valueType.includes(\" \")) valueType = `(${valueType})`;\n      valueType = `${valueType}[]`;\n    }\n  }\n\n  // a little messy, but if we have a map of arrays, we need to wrap the value after adding the array info\n  if (isMap && isMapOfArray)\n    valueType = isDocument ? `mongoose.Types.Map<${valueType}>` : `Map<string, ${valueType}>`;\n\n  if (val?.default === null) {\n    valueType += \" | null\";\n  }\n  return convertKeyValueToLine({ key, valueType, isOptional });\n};\n","/**\r\n * Parser types\r\n */\r\n\r\nimport {\r\n  convertBaseTypeToTs,\r\n  getTypeFromKeyValue,\r\n  getShouldLeanIncludeVirtuals,\r\n  getSubdocName\r\n} from \"./utils\";\r\nimport _ from \"lodash\";\r\nimport * as templates from \"../helpers/templates\";\r\nimport { MongooseModel, MongooseSchema, ParserSchemaField } from \"./types\";\r\nimport { sanitizeModelName } from \"../helpers/generator\";\r\n\r\n// old TODOs:\r\n// - Handle statics method issue\r\n// - Switch to using HydratedDocument, https://mongoosejs.com/docs/migrating_to_7.html. Also update query helpers https://mongoosejs.com/docs/typescript/query-helpers.html\r\n// TODO: Look into new inference of types https://mongoosejs.com/docs/typescript/schemas.html\r\n\r\nexport class ParserSchema {\r\n  modelName: string;\r\n  model: any; // TODO: Can we get better types here?\r\n  mongooseSchema: MongooseSchema;\r\n  fields: ParserSchemaField[];\r\n  methods: Record<string, string> = {};\r\n  statics: Record<string, string> = {};\r\n  queries: Record<string, string> = {};\r\n  virtuals: Record<string, string> = {};\r\n  comments: { path: string; comment: string }[] = [];\r\n\r\n  // schema.tree with custom field _aliasRootField, TODO: Create explicit type for this\r\n  schemaTree: MongooseSchema[\"tree\"] = {};\r\n\r\n  shouldLeanIncludeVirtuals: boolean;\r\n\r\n  childSchemas: ParserSchema[];\r\n\r\n  constructor({\r\n    mongooseSchema,\r\n    modelName,\r\n    model\r\n  }: {\r\n    mongooseSchema: MongooseSchema;\r\n    modelName: string;\r\n    model: MongooseModel;\r\n  }) {\r\n    this.model = model;\r\n    this.modelName = modelName;\r\n    this.mongooseSchema = mongooseSchema;\r\n    this.childSchemas = this.parseChildSchemas(mongooseSchema);\r\n\r\n    this.schemaTree = this.parseTree(mongooseSchema);\r\n\r\n    this.fields = this.generateFields(mongooseSchema);\r\n\r\n    this.shouldLeanIncludeVirtuals = getShouldLeanIncludeVirtuals(mongooseSchema);\r\n  }\r\n\r\n  // TODO: Generate own representation\r\n  private generateFields(_mongooseSchema: MongooseSchema): ParserSchemaField[] {\r\n    // return Object.entries(mongooseSchema.tree).map(([name, field]) => ({\r\n    //   name: field.name,\r\n    //   type: field.type,\r\n    //   isOptional: field.isOptional || false,\r\n    //   isArray: field.isArray || false,\r\n    //   isMap: field.isMap || false,\r\n    //   ref: field.ref,\r\n    //   virtual: field.virtual,\r\n    //   comment: field.comment\r\n    // }));\r\n    return [];\r\n  }\r\n\r\n  public generateTemplate({\r\n    isDocument,\r\n    noMongoose,\r\n    datesAsStrings,\r\n    header,\r\n    footer\r\n  }: {\r\n    isDocument: boolean;\r\n    noMongoose: boolean;\r\n    datesAsStrings: boolean;\r\n    header: string;\r\n    footer: string;\r\n  }): string {\r\n    let template = \"\";\r\n\r\n    if (this.mongooseSchema.childSchemas && this.modelName) {\r\n      // TODO: Splint into functuon\r\n      this.childSchemas.forEach((child) => {\r\n        const path = child.model.path;\r\n\r\n        const name = getSubdocName(path, this.modelName);\r\n\r\n        let header = \"\";\r\n        if (isDocument)\r\n          // TODO: Does this make sense for child docs?\r\n          header += child.mongooseSchema._isSubdocArray\r\n            ? templates.getSubdocumentDocs(this.modelName, path)\r\n            : templates.getDocumentDocs(this.modelName);\r\n        else header += templates.getLeanDocs(this.modelName, name);\r\n\r\n        header += \"\\nexport \";\r\n\r\n        if (isDocument) {\r\n          header += `type ${name}Document = `;\r\n\r\n          // get type of _id to pass to mongoose.Document\r\n          // this is likely unecessary, since non-subdocs are not allowed to have option _id: false (https://mongoosejs.com/docs/guide.html#_id)\r\n          // TODO: Fix type manually\r\n          const _idType = child.mongooseSchema.tree._id\r\n            ? convertBaseTypeToTs({\r\n                key: \"_id\",\r\n                val: child.mongooseSchema.tree._id,\r\n                isDocument: true,\r\n                noMongoose,\r\n                datesAsStrings\r\n              })\r\n            : \"any\";\r\n\r\n          // TODO: this should extend `${name}Methods` like normal docs, but generator will only have methods, statics, etc. under the model name, not the subdoc model name\r\n          // so after this is generated, we should do a pass and see if there are any child schemas that have non-subdoc definitions.\r\n          // or could just wait until we dont need duplicate subdoc versions of docs (use the same one for both embedded doc and non-subdoc)\r\n          header += child.mongooseSchema._isSubdocArray\r\n            ? `mongoose.Types.Subdocument<${_idType}>`\r\n            : `mongoose.Document<${_idType}>`;\r\n\r\n          header += \" & {\\n\";\r\n        } else header += `type ${name} = {\\n`;\r\n\r\n        const footer = `}\\n\\n`;\r\n        template += child.generateTemplate({\r\n          isDocument,\r\n          noMongoose,\r\n          datesAsStrings,\r\n          header,\r\n          footer\r\n        });\r\n      });\r\n    }\r\n\r\n    template += header;\r\n\r\n    Object.entries(this.schemaTree).forEach(([key, val]) => {\r\n      template += getTypeFromKeyValue({\r\n        key,\r\n        val,\r\n        isDocument,\r\n        noMongoose,\r\n        datesAsStrings,\r\n        shouldLeanIncludeVirtuals: this.shouldLeanIncludeVirtuals\r\n      });\r\n    });\r\n\r\n    template += footer;\r\n    return template;\r\n  }\r\n\r\n  /**\r\n   * Parses the schema tree, and adds _aliasRootField to the tree for aliases.\r\n   * @param schema The schema to parse.\r\n   * @returns The parsed schema tree.\r\n   */\r\n  parseTree = (schema: MongooseSchema): Record<string, any> => {\r\n    const tree = _.cloneDeep(schema.tree);\r\n\r\n    // TODO: Rename this to what it was before, related to adding type aliases\r\n    // Add alias types to tree\r\n    if (!_.isEmpty(this.mongooseSchema.aliases) && this.modelName) {\r\n      Object.entries(this.mongooseSchema.aliases).forEach(([alias, path]: [string, any]) => {\r\n        _.set(tree, `${alias}._aliasRootField`, _.get(tree, path));\r\n      });\r\n    }\r\n\r\n    return tree;\r\n  };\r\n\r\n  parseChildSchemas = (schema: MongooseSchema): ParserSchema[] => {\r\n    const childSchemas: ParserSchema[] = [];\r\n\r\n    // NOTE: The for loop below is a hack for Schema maps. For some reason, when a map of a schema exists, the schema is not included\r\n    // in childSchemas. So we add it manually and add a few extra properties to ensure the processChild works correctly.\r\n    // UPDSTE: Newer versions of Mongoose do include the schema map in the child schemas, but in a weird format with \"*$\" postfix in the path. We can just filter those out which is what were doing directly below.\r\n    const mongooseChildSchemas = _.cloneDeep(schema.childSchemas).filter(\r\n      (child) => !child.model.path.endsWith(\"$*\")\r\n    );\r\n\r\n    for (const [path, type] of Object.entries(this.mongooseSchema.paths)) {\r\n      // This check tells us that this is a map of a separate schema\r\n      if ((type as any)?.$isSchemaMap && (type as any)?.$__schemaType.schema) {\r\n        const childSchema = (type as any).$__schemaType;\r\n        childSchema.model = {\r\n          path: path,\r\n          // TODO: Augment the mongoose schema with these, or dont update them in place would be even better\r\n          $isArraySubdocument:\r\n            childSchema.Constructor?.$isArraySubdocument ??\r\n            childSchema.$isMongooseDocumentArray ??\r\n            false,\r\n          $isSchemaMap: true\r\n        };\r\n        mongooseChildSchemas.push(childSchema);\r\n      }\r\n    }\r\n\r\n    for (const child of mongooseChildSchemas) {\r\n      const path = child.model.path;\r\n      const isSubdocArray = child.model.$isArraySubdocument;\r\n      const isSchemaMap = child.model.$isSchemaMap ?? false;\r\n      const name = getSubdocName(path, this.modelName);\r\n      const sanitizedName = sanitizeModelName(name);\r\n\r\n      child.schema._isReplacedWithSchema = true;\r\n      child.schema._inferredInterfaceName = sanitizedName;\r\n      child.schema._isSubdocArray = isSubdocArray;\r\n      child.schema._isSchemaMap = isSchemaMap;\r\n\r\n      const requiredValuePath = `${path}.required`;\r\n      if (_.get(this.mongooseSchema.tree, requiredValuePath) === true) {\r\n        child.schema.required = true;\r\n      }\r\n\r\n      /**\r\n       * for subdocument arrays, mongoose supports passing `default: undefined` to disable the default empty array created.\r\n       * here we indicate this on the child schema using _isDefaultSetToUndefined so that the parser properly sets the `isOptional` flag\r\n       */\r\n      if (isSubdocArray) {\r\n        const defaultValuePath = `${path}.default`;\r\n        if (\r\n          _.has(this.mongooseSchema.tree, defaultValuePath) &&\r\n          _.get(this.mongooseSchema.tree, defaultValuePath) === undefined\r\n        ) {\r\n          child.schema._isDefaultSetToUndefined = true;\r\n        }\r\n      }\r\n\r\n      if (isSchemaMap) {\r\n        _.set(this.mongooseSchema.tree, path, {\r\n          type: Map,\r\n          of: isSubdocArray ? [child.schema] : child.schema\r\n        });\r\n      } else if (isSubdocArray) {\r\n        _.set(this.mongooseSchema.tree, path, [child.schema]);\r\n      } else {\r\n        _.set(this.mongooseSchema.tree, path, child.schema);\r\n      }\r\n\r\n      const childSchema = new ParserSchema({\r\n        mongooseSchema: child.schema,\r\n        modelName: sanitizedName,\r\n        model: child.model\r\n      });\r\n\r\n      childSchemas.push(childSchema);\r\n    }\r\n\r\n    return childSchemas;\r\n  };\r\n}\r\n","import {\r\n  TS_IDENTIFIER_SEPARATOR_REGEX,\r\n  TS_INVALID_CHAR_REGEX,\r\n  TS_INVALID_START_REGEX,\r\n  tsReservedKeywords\r\n} from \"./constants\";\r\n\r\n/**\r\n * Converts a string into a valid TypeScript type identifier by:\r\n * 1. Validating input\r\n * 2. Splitting on non-alphanumeric characters\r\n * 3. Removing invalid characters\r\n * 4. Ensuring valid start characters (letters, _, $)\r\n * 5. Converting to PascalCase\r\n *\r\n * @param input - The string to convert into a valid TypeScript type identifier\r\n * @returns A valid TypeScript type identifier in PascalCase\r\n * @throws {TypeError} If the input is not a string\r\n * @throws {Error} If the input is empty or results in an empty string after processing\r\n *\r\n * @example\r\n * // Basic conversion\r\n * sanitizeTypeIdentifier(\"hello world\")      // Returns \"HelloWorld\"\r\n * sanitizeTypeIdentifier(\"my-component-123\") // Returns \"MyComponent123\"\r\n *\r\n * @example\r\n * // Edge cases\r\n * sanitizeTypeIdentifier(\"123-invalid\")     // Returns \"Invalid\"\r\n * sanitizeTypeIdentifier(\"user.profile\")    // Returns \"UserProfile\"\r\n * sanitizeTypeIdentifier(\"$special_case\")   // Returns \"SpecialCase\"\r\n * sanitizeTypeIdentifier(\"  trimmed  \")     // Returns \"Trimmed\"\r\n */\r\nexport function sanitizeTypeIdentifier(input: string): string {\r\n  // Input validation\r\n  if (typeof input !== \"string\") {\r\n    throw new TypeError(`Model name must be a string, received: ${typeof input}`);\r\n  }\r\n\r\n  const trimmedInput = input.trim();\r\n  if (!trimmedInput) {\r\n    throw new Error(\"Type identifier cannot be empty\");\r\n  }\r\n\r\n  // Check if input is a reserved keyword\r\n  if (tsReservedKeywords.includes(trimmedInput as any)) {\r\n    throw new Error(\r\n      `Invalid model name: \"${trimmedInput}\" - cannot use TypeScript reserved keyword`\r\n    );\r\n  }\r\n\r\n  // Split by common separators and filter out empty strings\r\n  const parts = trimmedInput.split(TS_IDENTIFIER_SEPARATOR_REGEX).filter(Boolean);\r\n\r\n  // Process each part\r\n  const sanitizedParts = parts\r\n    .map((part, index) => {\r\n      // Remove invalid characters\r\n      const cleaned = part.replace(TS_INVALID_CHAR_REGEX, \"\");\r\n\r\n      // For first part: remove leading numbers/invalid characters\r\n      // For other parts: keep numbers (even at start)\r\n      const validStart = index === 0 ? cleaned.replace(TS_INVALID_START_REGEX, \"\") : cleaned;\r\n\r\n      // Capitalize first letter if it exists\r\n      return validStart.charAt(0).toUpperCase() + validStart.slice(1);\r\n    })\r\n    .filter(Boolean); // Remove any parts that became empty after cleaning\r\n\r\n  // Check if first character is a number\r\n  if (/^\\d/.test(trimmedInput)) {\r\n    throw new Error(`Invalid model name: \"${trimmedInput}\" - type name cannot start with a number`);\r\n  }\r\n\r\n  // Ensure we have valid parts after processing\r\n  if (sanitizedParts.length === 0) {\r\n    throw new Error(\r\n      `Invalid model name: \"${trimmedInput}\" - results in invalid TypeScript identifier \"\"`\r\n    );\r\n  }\r\n\r\n  return sanitizedParts.join(\"\");\r\n}\r\n","import { Project, SourceFile, SyntaxKind, PropertySignature } from \"ts-morph\";\r\nimport * as templates from \"./templates\";\r\nimport { TsReaderModelTypes } from \"../types\";\r\nimport { ParserSchema } from \"../parser/schema\";\r\nimport { convertBaseTypeToTs, getShouldLeanIncludeVirtuals, loadModels } from \"../parser/utils\";\r\nimport { MongooseModel } from \"../parser/types\";\r\nimport { convertKeyValueToLine } from \"../writer/stringBuilder\";\r\nimport { sanitizeTypeIdentifier } from \"./typeSanitization\";\r\n\r\n// TODO next: Pull this file apart. Create a new \"file writer\" file, move all the ts stuff somewhere else,\r\n\r\nexport const cleanComment = (comment: string): string => {\r\n  if (!comment) return \"\";\r\n  if (comment.trim() === \"/** */\") return \"\";\r\n\r\n  return comment\r\n    .replace(/^\\/\\*\\*[^\\S\\r\\n]?/, \"\") // Remove opening /**\r\n    .replace(/[^\\S\\r\\n]+\\*\\s/g, \"\") // Remove * at start of lines\r\n    .replace(/(\\n)?[^\\S\\r\\n]+\\*\\/$/, \"\"); // Remove closing */\r\n};\r\n\r\n// Needs to be exported by generator Module\r\nexport const sanitizeModelName = (name: string) => sanitizeTypeIdentifier(name);\r\n\r\ninterface ParsedSignature {\r\n  params: string;\r\n  returnType: string;\r\n  thisType: string;\r\n}\r\n\r\nconst funcTypeToThisSuffix = {\r\n  query: \"Query\",\r\n  methods: \"Document\",\r\n  statics: \"Model\"\r\n} as const;\r\n\r\nconst parseSignature = (\r\n  signature: string,\r\n  modelName: string,\r\n  funcType: \"query\" | \"methods\" | \"statics\"\r\n): ParsedSignature => {\r\n  const thisSuffix = funcTypeToThisSuffix[funcType];\r\n  const thisType = `${modelName}${thisSuffix}`;\r\n  const queryReturnType = `${modelName}Query`;\r\n\r\n  const match = signature?.match(/\\((?:this: \\w*(?:, )?)?(?<params>.*)\\) => (?<returnType>.*)/);\r\n\r\n  if (!match?.groups) {\r\n    console.warn(\r\n      `Failed to extract types from function signature: ${signature}, falling back to defaults`\r\n    );\r\n    const defaultReturnType = funcType === \"query\" ? queryReturnType : \"any\";\r\n    const defaultParams = \"...args: any[]\";\r\n\r\n    return {\r\n      params: defaultParams,\r\n      returnType: defaultReturnType,\r\n      thisType\r\n    };\r\n  }\r\n\r\n  const finalReturnType = funcType === \"query\" ? queryReturnType : match.groups.returnType;\r\n\r\n  return {\r\n    params: match.groups.params,\r\n    returnType: finalReturnType,\r\n    thisType\r\n  };\r\n};\r\n\r\nexport const convertFuncSignatureToType = (\r\n  funcSignature: string,\r\n  funcType: \"query\" | \"methods\" | \"statics\",\r\n  modelName: string\r\n): string => {\r\n  const sanitizedModelName = sanitizeModelName(modelName);\r\n  const { params, returnType, thisType } = parseSignature(\r\n    funcSignature,\r\n    sanitizedModelName,\r\n    funcType\r\n  );\r\n\r\n  const paramsString = params?.length > 0 ? `, ${params}` : \"\";\r\n  return `(this: ${thisType}${paramsString}) => ${returnType}`;\r\n};\r\n\r\nexport const replaceModelTypes = (\r\n  sourceFile: SourceFile,\r\n  modelTypes: TsReaderModelTypes,\r\n  models: MongooseModel[]\r\n) => {\r\n  Object.entries(modelTypes).forEach(([modelName, types]) => {\r\n    const sanitizedModelName = sanitizeModelName(modelName);\r\n    const { methods, statics, query, virtuals, comments } = types;\r\n\r\n    // methods\r\n    if (Object.keys(methods).length > 0) {\r\n      sourceFile\r\n        ?.getTypeAlias(`${sanitizedModelName}Methods`)\r\n        ?.getFirstChildByKind(SyntaxKind.TypeLiteral)\r\n        ?.getChildrenOfKind(SyntaxKind.PropertySignature)\r\n        .forEach((prop) => {\r\n          const signature = methods[prop.getName()];\r\n          if (signature) {\r\n            const funcType = convertFuncSignatureToType(signature, \"methods\", modelName);\r\n            prop.setType(funcType);\r\n          }\r\n        });\r\n    }\r\n\r\n    // statics\r\n    if (Object.keys(statics).length > 0) {\r\n      sourceFile\r\n        ?.getTypeAlias(`${sanitizedModelName}Statics`)\r\n        ?.getFirstChildByKind(SyntaxKind.TypeLiteral)\r\n        ?.getChildrenOfKind(SyntaxKind.PropertySignature)\r\n        .forEach((prop) => {\r\n          const signature = statics[prop.getName()];\r\n          if (signature) {\r\n            const funcType = convertFuncSignatureToType(signature, \"statics\", modelName);\r\n            prop.setType(funcType);\r\n          }\r\n        });\r\n    }\r\n\r\n    // queries\r\n    if (Object.keys(query).length > 0) {\r\n      sourceFile\r\n        ?.getTypeAlias(`${sanitizedModelName}Queries`)\r\n        ?.getFirstChildByKind(SyntaxKind.TypeLiteral)\r\n        ?.getChildrenOfKind(SyntaxKind.PropertySignature)\r\n        .forEach((prop) => {\r\n          const signature = query[prop.getName()];\r\n          if (signature) {\r\n            const funcType = convertFuncSignatureToType(signature, \"query\", modelName);\r\n            prop.setType(funcType);\r\n          }\r\n        });\r\n    }\r\n\r\n    // virtuals\r\n    const virtualNames = Object.keys(virtuals);\r\n    if (virtualNames.length > 0) {\r\n      const documentProperties = sourceFile\r\n        ?.getTypeAlias(`${sanitizedModelName}Document`)\r\n        ?.getFirstChildByKind(SyntaxKind.IntersectionType)\r\n        ?.getFirstChildByKind(SyntaxKind.TypeLiteral)\r\n        ?.getChildrenOfKind(SyntaxKind.PropertySignature);\r\n\r\n      const { schema } = models.find((model) => model.modelName === modelName)!;\r\n\r\n      const leanProperties =\r\n        getShouldLeanIncludeVirtuals(schema) &&\r\n        sourceFile\r\n          ?.getTypeAlias(`${sanitizedModelName}`)\r\n          ?.getFirstChildByKind(SyntaxKind.TypeLiteral)\r\n          ?.getChildrenOfKind(SyntaxKind.PropertySignature);\r\n\r\n      if (documentProperties || leanProperties) {\r\n        virtualNames.forEach((virtualName) => {\r\n          const virtualNameComponents = virtualName.split(\".\");\r\n          let nestedDocProps: PropertySignature[] | undefined;\r\n          let nestedLeanProps: PropertySignature[] | undefined;\r\n\r\n          virtualNameComponents.forEach((nameComponent, i) => {\r\n            if (i === virtualNameComponents.length - 1) {\r\n              if (documentProperties) {\r\n                const docPropMatch = (nestedDocProps ?? documentProperties).find(\r\n                  (prop) => prop.getName() === nameComponent\r\n                );\r\n                docPropMatch?.setType(virtuals[virtualName]);\r\n              }\r\n              if (leanProperties) {\r\n                const leanPropMatch = (nestedLeanProps ?? leanProperties).find(\r\n                  (prop) => prop.getName() === nameComponent\r\n                );\r\n                leanPropMatch?.setType(virtuals[virtualName]);\r\n              }\r\n\r\n              return;\r\n            }\r\n\r\n            if (documentProperties) {\r\n              nestedDocProps = (nestedDocProps ?? documentProperties)\r\n                .find((prop) => prop.getName() === nameComponent)\r\n                ?.getFirstChildByKind(SyntaxKind.TypeLiteral)\r\n                ?.getChildrenOfKind(SyntaxKind.PropertySignature);\r\n            }\r\n            if (leanProperties) {\r\n              nestedLeanProps = (nestedLeanProps ?? leanProperties)\r\n                .find((prop) => prop.getName() === nameComponent)\r\n                ?.getFirstChildByKind(SyntaxKind.TypeLiteral)\r\n                ?.getChildrenOfKind(SyntaxKind.PropertySignature);\r\n            }\r\n          });\r\n        });\r\n      }\r\n    }\r\n\r\n    // TODO: this section is almost identical to the virtual property section above, refactor\r\n    if (comments.length > 0) {\r\n      const documentProperties = sourceFile\r\n        ?.getTypeAlias(`${sanitizedModelName}Document`)\r\n        ?.getFirstChildByKind(SyntaxKind.IntersectionType)\r\n        ?.getFirstChildByKind(SyntaxKind.TypeLiteral)\r\n        ?.getChildrenOfKind(SyntaxKind.PropertySignature);\r\n\r\n      const leanProperties = sourceFile\r\n        ?.getTypeAlias(`${sanitizedModelName}`)\r\n        ?.getFirstChildByKind(SyntaxKind.TypeLiteral)\r\n        ?.getChildrenOfKind(SyntaxKind.PropertySignature);\r\n\r\n      comments.forEach(({ path, comment }) => {\r\n        const pathComponents = path.split(\".\");\r\n        let nestedDocProps: PropertySignature[] | undefined;\r\n        let nestedLeanProps: PropertySignature[] | undefined;\r\n\r\n        pathComponents.forEach((nameComponent, i) => {\r\n          if (i === pathComponents.length - 1) {\r\n            if (documentProperties) {\r\n              const docPropMatch = (nestedDocProps ?? documentProperties).find(\r\n                (prop) => prop.getName() === nameComponent\r\n              );\r\n\r\n              docPropMatch?.addJsDoc(cleanComment(comment));\r\n            }\r\n            if (leanProperties) {\r\n              const leanPropMatch = (nestedLeanProps ?? leanProperties).find(\r\n                (prop) => prop.getName() === nameComponent\r\n              );\r\n\r\n              leanPropMatch?.addJsDoc(cleanComment(comment));\r\n            }\r\n\r\n            return;\r\n          }\r\n\r\n          if (documentProperties) {\r\n            nestedDocProps = (nestedDocProps ?? documentProperties)\r\n              .find((prop) => prop.getName() === nameComponent)\r\n              ?.getFirstChildByKind(SyntaxKind.TypeLiteral)\r\n              ?.getChildrenOfKind(SyntaxKind.PropertySignature);\r\n          }\r\n          if (leanProperties) {\r\n            nestedLeanProps = (nestedLeanProps ?? leanProperties)\r\n              .find((prop) => prop.getName() === nameComponent)\r\n              ?.getFirstChildByKind(SyntaxKind.TypeLiteral)\r\n              ?.getChildrenOfKind(SyntaxKind.PropertySignature);\r\n          }\r\n        });\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\nexport const addPopulateHelpers = (sourceFile: SourceFile) => {\r\n  sourceFile.addStatements(\"\\n\" + templates.POPULATE_HELPERS);\r\n};\r\n\r\nexport const overloadQueryPopulate = (sourceFile: SourceFile) => {\r\n  sourceFile.addStatements(\"\\n\" + templates.QUERY_POPULATE);\r\n};\r\n\r\nexport const createSourceFile = (genPath: string) => {\r\n  const project = new Project();\r\n  const sourceFile = project.createSourceFile(genPath, \"\", { overwrite: true });\r\n  return sourceFile;\r\n};\r\n\r\n// TODO: statics, query, methods should all be parsed in the parser, and then written in the stringBuilder\r\nexport const parseFunctions = (\r\n  funcs: { [key: string]: () => any },\r\n  modelName: string,\r\n  funcType: \"methods\" | \"statics\" | \"query\"\r\n) => {\r\n  let interfaceString = \"\";\r\n\r\n  Object.keys(funcs).forEach((key) => {\r\n    if ([\"initializeTimestamps\"].includes(key)) return;\r\n\r\n    const funcSignature = \"(...args: any[]) => any\";\r\n    const type = convertFuncSignatureToType(funcSignature, funcType, modelName);\r\n    interfaceString += convertKeyValueToLine({ key, valueType: type });\r\n  });\r\n\r\n  return interfaceString;\r\n};\r\n\r\nexport const getSchemaTypes = (model: MongooseModel) => {\r\n  const { modelName, schema } = model;\r\n  const sanitizedModelName = sanitizeModelName(modelName);\r\n  let schemaTypes = \"\";\r\n\r\n  // add type alias to modelName so that it can be imported without clashing with the mongoose model\r\n  schemaTypes += templates.getObjectDocs(sanitizedModelName);\r\n  schemaTypes += `\\nexport type ${sanitizedModelName}Object = ${sanitizedModelName}\\n\\n`;\r\n\r\n  schemaTypes += templates.getQueryDocs();\r\n  schemaTypes += `\\nexport type ${sanitizedModelName}Query = mongoose.Query<any, ${sanitizedModelName}Document, ${sanitizedModelName}Queries> & ${sanitizedModelName}Queries\\n\\n`;\r\n\r\n  schemaTypes += templates.getQueryHelpersDocs(sanitizedModelName);\r\n  schemaTypes += `\\nexport type ${sanitizedModelName}Queries = {\\n`;\r\n  schemaTypes += parseFunctions(schema.query ?? {}, modelName, \"query\");\r\n  schemaTypes += \"}\\n\";\r\n\r\n  schemaTypes += `\\nexport type ${sanitizedModelName}Methods = {\\n`;\r\n  schemaTypes += parseFunctions(schema.methods, modelName, \"methods\");\r\n  schemaTypes += \"}\\n\";\r\n\r\n  schemaTypes += `\\nexport type ${sanitizedModelName}Statics = {\\n`;\r\n  schemaTypes += parseFunctions(schema.statics, modelName, \"statics\");\r\n  schemaTypes += \"}\\n\\n\";\r\n\r\n  const modelExtend = `mongoose.Model<${sanitizedModelName}Document, ${sanitizedModelName}Queries>`;\r\n\r\n  schemaTypes += templates.getModelDocs(sanitizedModelName);\r\n  schemaTypes += `\\nexport type ${sanitizedModelName}Model = ${modelExtend} & ${sanitizedModelName}Statics\\n\\n`;\r\n\r\n  schemaTypes += templates.getSchemaDocs(sanitizedModelName);\r\n  schemaTypes += `\\nexport type ${sanitizedModelName}Schema = mongoose.Schema<${sanitizedModelName}Document, ${sanitizedModelName}Model, ${sanitizedModelName}Methods, ${sanitizedModelName}Queries>\\n\\n`;\r\n\r\n  return schemaTypes;\r\n};\r\n\r\n// TODO: This should be split up, shouldn't be writing to file and parsing schema simultaneously. Instead parse schema first then write later.\r\nexport const generateTypes = async ({\r\n                                      sourceFile,\r\n                                      imports = [],\r\n                                      modelsPaths,\r\n                                      noMongoose,\r\n                                      datesAsStrings\r\n                                    }: {\r\n  sourceFile: SourceFile;\r\n  modelsPaths: string[];\r\n  imports?: string[];\r\n  noMongoose: boolean;\r\n  datesAsStrings: boolean;\r\n}) => {\r\n  const models = await loadModels(modelsPaths); // Add await here\r\n\r\n  sourceFile.addStatements((writer) => {\r\n    writer.write(templates.MAIN_HEADER).blankLine();\r\n    // mongoose import\r\n    if (!noMongoose) writer.write(templates.MONGOOSE_IMPORT);\r\n\r\n    // custom, user-defined imports\r\n    if (imports.length > 0) writer.write(imports.join(\"\\n\"));\r\n\r\n    writer.blankLine();\r\n\r\n    models.forEach((model) => {\r\n      const { modelName, schema } = model;\r\n      const sanitizedModelName = sanitizeModelName(modelName);\r\n\r\n      const leanHeader =\r\n        templates.getLeanDocs(sanitizedModelName) + `\\nexport type ${sanitizedModelName} = {\\n`;\r\n      const leanFooter = \"}\";\r\n\r\n      const parserSchema = new ParserSchema({\r\n        mongooseSchema: schema,\r\n        modelName: sanitizedModelName,\r\n        model\r\n      });\r\n\r\n      const leanInterfaceStr = parserSchema.generateTemplate({\r\n        isDocument: false,\r\n        noMongoose,\r\n        datesAsStrings,\r\n        header: leanHeader,\r\n        footer: leanFooter\r\n      });\r\n\r\n      writer.write(leanInterfaceStr).blankLine();\r\n\r\n      // if noMongoose, skip adding document types\r\n      if (noMongoose) {\r\n        return;\r\n      }\r\n\r\n      // get type of _id to pass to mongoose.Document\r\n      const _idType = schema.tree._id\r\n        ? convertBaseTypeToTs({\r\n            key: \"_id\",\r\n            val: schema.tree._id,\r\n            isDocument: true,\r\n            noMongoose,\r\n            datesAsStrings\r\n          })\r\n        : \"any\";\r\n      const mongooseDocExtend = `mongoose.Document<${_idType}, ${sanitizedModelName}Queries>`;\r\n\r\n      let documentInterfaceStr = \"\";\r\n      documentInterfaceStr += getSchemaTypes(model);\r\n\r\n      const documentHeader =\r\n        templates.getDocumentDocs(sanitizedModelName) +\r\n        `\\nexport type ${sanitizedModelName}Document = ${mongooseDocExtend} & ${sanitizedModelName}Methods & {\\n`;\r\n      const documentFooter = \"}\";\r\n\r\n      documentInterfaceStr += parserSchema.generateTemplate({\r\n        isDocument: true,\r\n        noMongoose,\r\n        datesAsStrings,\r\n        header: documentHeader,\r\n        footer: documentFooter\r\n      });\r\n\r\n      writer.write(documentInterfaceStr).blankLine();\r\n    });\r\n  });\r\n\r\n  return sourceFile;\r\n};\r\n\r\nexport const saveFile = ({ sourceFile }: { sourceFile: SourceFile; generatedFilePath: string }) => {\r\n  try {\r\n    sourceFile.saveSync();\r\n  } catch (err) {\r\n    console.error(err);\r\n    throw err;\r\n  }\r\n};\r\n","import { Interfaces, Flags } from \"@oclif/core\";\n\nexport const helpFlag = (opts: Partial<Interfaces.BooleanFlag<boolean>> = {}) => {\n  return Flags.boolean({\n    description: \"Show CLI help.\",\n    ...opts,\n    parse: async () => {\n      // Just return true - oclif will handle the help display\n      return true;\n    }\n  });\n};\n","import { Args, Command, Config, Interfaces, Flags, ux } from \"@oclif/core\";\n\nimport * as tsReader from \"./helpers/tsReader\";\nimport * as paths from \"./helpers/paths\";\nimport * as formatter from \"./helpers/formatter\";\nimport * as generator from \"./helpers/generator\";\nimport * as cli from \"./helpers/cli\";\nimport * as types from \"./types\";\nimport { loadModels } from \"./parser/utils\";\n\nimport { fileURLToPath } from \"url\";\nimport { dirname } from \"path\";\n\n// At the top level of your file\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\ndeclare namespace MongooseTsgen {\n  export type FlagConfig = types.Normalize<\n    Omit<Interfaces.InferredFlags<typeof MongooseTsgen[\"flags\"]>, \"help\">\n  >;\n  export type ArgConfig = types.Normalize<Interfaces.InferredArgs<typeof MongooseTsgen[\"args\"]>>;\n\n  export interface Config {\n    flags: FlagConfig;\n    args: ArgConfig;\n  }\n}\n\n// eslint-disable-next-line no-redeclare\nclass MongooseTsgen extends Command {\n  static id = \".\";\n\n  static description =\n    \"Generate a Typescript file containing Mongoose Schema typings.\\nSpecify the directory of your Mongoose model definitions using `MODEL_PATH`. If left blank, all sub-directories will be searched for `models/*.ts` (ignores `index.ts` files). Files found are expected to export a Mongoose model.\";\n\n  static flags = {\n    config: Flags.string({\n      char: \"c\",\n      description:\n        \"[default: ./] Path of `mtgen.config.json` or its root folder. CLI flag options will take precendence over settings in `mtgen.config.json`.\"\n    }),\n    \"dry-run\": Flags.boolean({\n      char: \"d\",\n      description: \"Print output rather than writing to file.\"\n    }),\n    help: cli.helpFlag({\n      char: \"h\"\n    }),\n    imports: Flags.string({\n      char: \"i\",\n      description:\n        \"Custom import statements to add to the output file. Useful if you use third-party types in your mongoose schema definitions. For multiple imports, specify this flag more than once.\",\n      multiple: true\n    }),\n    \"no-format\": Flags.boolean({\n      description: \"Disable formatting generated files with prettier.\"\n    }),\n    output: Flags.string({\n      char: \"o\",\n      description:\n        \"[default: ./src/interfaces] Path of output file to write generated typings. If a folder path is passed, the generator will create a `mongoose.gen.ts` file in the specified folder.\"\n    }),\n    project: Flags.string({\n      char: \"p\",\n      description: \"[default: ./] Path of `tsconfig.json` or its root folder.\"\n    }),\n    debug: Flags.boolean({\n      description: \"Print debug information if anything isn't working\"\n    }),\n    \"no-mongoose\": Flags.boolean({\n      description:\n        \"Don't generate types that reference mongoose (i.e. documents). Replace ObjectId with string.\"\n    }),\n    \"dates-as-strings\": Flags.boolean({\n      description:\n        \"Dates will be typed as strings. Useful for types returned to a frontend by API requests.\"\n    }),\n    \"no-populate-overload\": Flags.boolean({\n      description:\n        \"Disable augmenting mongoose with Query.populate overloads (the overloads narrow the return type of populated documents queries).\"\n    }),\n    \"no-experimental-resolver\": Flags.boolean({\n      description:\n        \"Turn off experimentalResolver of the ts-node. It would help to resolve conflicting issue with some external modules.\"\n    })\n  };\n\n  // path of mongoose models folder\n  static args = {\n    model_path: Args.string()\n  };\n\n  constructor(argv: string[] = [], config = new Config({ root: __dirname })) {\n    super(argv, config);\n  }\n\n  private async getConfig(\n    customConfig: MongooseTsgen.Config\n  ): Promise<\n    MongooseTsgen.Config & { flags: MongooseTsgen.FlagConfig & { output: string; project: string } }\n  > {\n    const configFileFlags: Partial<MongooseTsgen.FlagConfig> = paths.getConfigFromFile(\n      customConfig.flags.config\n    );\n\n    return {\n      flags: {\n        ...configFileFlags,\n        ...customConfig.flags,\n\n        // We dont need the config field anymore now that we've merged the config file here\n        config: undefined,\n\n        // we cant set flags as `default` using the official oclif method since the defaults would overwrite flags provided in the config file.\n        // instead, well just set \"output\" and \"project\" as default manually if theyre still missing after merge with configFile.\n        output: configFileFlags?.output ?? customConfig.flags.output ?? \"./src/interfaces\",\n        project: configFileFlags?.project ?? customConfig.flags.project ?? \"./\"\n      },\n      args: {\n        ...configFileFlags,\n        ...customConfig.args\n      }\n    };\n  }\n\n  async run() {\n    const customConfig = await this.parse(MongooseTsgen);\n    try {\n      await this.generateDefinitions(customConfig);\n    } catch (error) {\n      this.error(error as Error, { exit: 1 });\n    }\n  }\n\n  async generateDefinitions(customConfig: MongooseTsgen.Config) {\n    ux.action.start(\"Generating mongoose typescript definitions\");\n\n    const { flags, args } = await this.getConfig(customConfig);\n\n    if (flags.debug) {\n      this.log(\"Debug mode enabled\");\n      process.env.DEBUG = \"1\";\n    }\n\n    const modelsPaths = paths.getModelsPaths(args.model_path);\n\n    const cleanupTs = await tsReader.registerUserTs(flags.project);\n\n    const generatedFilePath = paths.cleanOutputPath(flags.output);\n    let sourceFile = generator.createSourceFile(generatedFilePath);\n\n    const noMongoose = flags[\"no-mongoose\"];\n    const datesAsStrings = flags[\"dates-as-strings\"];\n    sourceFile = await generator.generateTypes({\n      modelsPaths,\n      sourceFile,\n      imports: flags.imports,\n      noMongoose,\n      datesAsStrings\n    });\n\n    const modelTypes = tsReader.getModelTypes(modelsPaths);\n    const models = loadModels(modelsPaths);\n    generator.replaceModelTypes(sourceFile, modelTypes, await models);\n\n    // only get model types (methods, statics, queries & virtuals) if user does not specify `noMongoose`,\n    if (noMongoose) {\n      this.log(\"Skipping TS model parsing and sourceFile model type replacement\");\n    } else {\n      // add populate helpers\n      await generator.addPopulateHelpers(sourceFile);\n      // add mongoose.Query.populate overloads\n      if (!flags[\"no-populate-overload\"]) {\n        await generator.overloadQueryPopulate(sourceFile);\n      }\n    }\n\n    cleanupTs?.();\n\n    if (flags[\"dry-run\"]) {\n      this.log(\"Dry run detected, generated interfaces will be printed to console:\\n\");\n      this.log(sourceFile.getFullText());\n    } else {\n      this.log(`Writing interfaces to ${generatedFilePath}`);\n\n      generator.saveFile({ generatedFilePath, sourceFile });\n\n      if (!flags[\"no-format\"]) await formatter.format([generatedFilePath]);\n      this.log(\"Writing complete 🐒\");\n    }\n\n    ux.action.stop();\n\n    return { generatedFilePath, sourceFile };\n  }\n}\n\nexport const run = async (): Promise<void> => {\n  return await MongooseTsgen.run(process.argv.slice(2));\n};\n\nexport default MongooseTsgen;\n"],"names":["fs","templates.getSubdocumentDocs","templates.getDocumentDocs","templates.getLeanDocs","templates.POPULATE_HELPERS","templates.QUERY_POPULATE","templates.getObjectDocs","templates.getQueryDocs","templates.getQueryHelpersDocs","templates.getModelDocs","templates.getSchemaDocs","templates.MAIN_HEADER","templates.MONGOOSE_IMPORT","cli.helpFlag","paths.getConfigFromFile","paths.getModelsPaths","tsReader.registerUserTs","paths.cleanOutputPath","generator.createSourceFile","generator.generateTypes","tsReader.getModelTypes","generator.replaceModelTypes","generator.addPopulateHelpers","generator.overloadQueryPopulate","generator.saveFile","formatter.format"],"mappings":"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"}